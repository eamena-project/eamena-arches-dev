{"version":3,"sources":["webpack://window.toGeoJSON/webpack/bootstrap","webpack://window.toGeoJSON/./node_modules/process/browser.js","webpack://window.toGeoJSON/./node_modules/@mapbox/togeojson/togeojson.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","h","charCodeAt","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","numarray","j","nodeVal","el","normalize","textContent","getMulti","ys","k","extend","coord1","v","replace","split","coord","coords","coordPair","ll","ele","heartRate","time","isNaN","coordinates","xml2str","str","undefined","xml","serializeToString","XMLSerializer","kml","doc","gj","type","features","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","hash","toString","pairs","pairsMap","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoords","root","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","properties","address","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","end","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","feature","geometry","geometries","id","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","segments","getProperties","getLineStyle","prop","extensions","links","link","href"],"mappings":"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","file":"togeojson-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    address = nodeVal(get1(root, 'address')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (address) properties.address = address;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                extend(properties, getLineStyle(get1(node, 'extensions')));\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var prop = getProperties(node);\n                extend(prop, getLineStyle(get1(node, 'extensions')));\n                var routeObj = {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getLineStyle(extensions) {\n                var style = {};\n                if (extensions) {\n                    var lineStyle = get1(extensions, 'line');\n                    if (lineStyle) {\n                        var color = nodeVal(get1(lineStyle, 'color')),\n                            opacity = parseFloat(nodeVal(get1(lineStyle, 'opacity'))),\n                            width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                        if (color) style.stroke = color;\n                        if (!isNaN(opacity)) style['stroke-opacity'] = opacity;\n                        // GPX width is in mm, convert to px with 96 px per inch\n                        if (!isNaN(width)) style['stroke-width'] = width * 96 / 25.4;\n                    }\n                }\n                return style;\n            }\n            function getProperties(node) {\n                var prop = getMulti(node, ['name', 'cmt', 'desc', 'type', 'time', 'keywords']),\n                    links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;"],"sourceRoot":""}