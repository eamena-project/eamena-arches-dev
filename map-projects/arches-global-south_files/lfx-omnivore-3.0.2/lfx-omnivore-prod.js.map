{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"toGeoJSON\"","webpack:///external \"topojson\"","webpack:///./node_modules/polyline/src/polyline.js","webpack:///./node_modules/wellknown/index.js","webpack:///external \"csv2geojson\"","webpack:///./node_modules/corslite/corslite.js","webpack:///./node_modules/@mapbox/leaflet-omnivore/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","toGeoJSON","topojson","polyline","encode","coordinate","factor","Math","round","output","String","fromCharCode","flipped","coords","length","push","slice","reverse","decode","str","precision","latitude_change","index","lat","lng","coordinates","shift","result","byte","pow","charCodeAt","a","b","fromGeoJSON","geojson","type","geometry","Error","parse","stringify","gj","pairWKT","join","ringWKT","map","ringsWKT","wrapParens","geometries","numberRegexp","tuples","RegExp","source","input","obj","parts","split","_","pop","srid","$","re","match","substring","white","multicoords","elem","depth","rings","stack","pointer","some","isNaN","Array","apply","parseFloat","item","pt","list","root","point","linestring","polygon","newCoordsFormat","indexOf","replace","multipoint","multilinestring","multipolygon","geometrycollection","crs","properties","csv2geojson","url","callback","cors","sent","window","XMLHttpRequest","location","protocol","hostname","port","x","XDomainRequest","original","this","arguments","that","args","setTimeout","loaded","status","undefined","onload","onreadystatechange","readyState","onerror","evt","onprogress","ontimeout","onabort","open","send","xhr","wellknown","addData","setGeoJSON","topojsonParse","data","options","layer","JSON","L","geoJson","objects","ft","feature","features","csvParse","csv","err","fire","error","gpxParse","gpx","xml","parseXML","kmlParse","kml","polylineParse","txt","wktParse","wkt","DOMParser","parseFromString","customLayer","response","responseText","avoidReady","on","off","responseXML"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,GAIA3B,IAAA4B,EAAA,mBCnEAzB,EAAAD,QAAA2B,yBCAA1B,EAAAD,QAAA4B,uCCWA,IAAAC,KAEA,SAAAC,EAAAC,EAAAC,GACAD,EAAAE,KAAAC,MAAAH,EAAAC,IACAD,IAAA,GACA,IACAA,MAGA,IADA,IAAAI,EAAA,GACAJ,GAAA,IACAI,GAAAC,OAAAC,aAAA,UAAAN,IACAA,IAAA,EAGA,OADAI,GAAAC,OAAAC,aAAAN,EAAA,IAsFA,SAAAO,EAAAC,GAEA,IADA,IAAAD,KACApC,EAAA,EAAmBA,EAAAqC,EAAAC,OAAmBtC,IACtCoC,EAAAG,KAAAF,EAAArC,GAAAwC,QAAAC,WAEA,OAAAL,EA5EAT,EAAAe,OAAA,SAAAC,EAAAC,GAeA,IAdA,IAOAC,EAPAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,KACAC,EAAA,EACAC,EAAA,EACAC,EAAA,KAGAtB,EAAAC,KAAAsB,IAAA,GAAAT,GAAA,GAKAE,EAAAH,EAAAL,QAAA,CAGAc,EAAA,KACAF,EAAA,EACAC,EAAA,EAEA,GAEAA,IAAA,IADAC,EAAAT,EAAAW,WAAAR,KAAA,MACAI,EACAA,GAAA,QACSE,GAAA,IAETP,EAAA,EAAAM,OAAA,GAAAA,GAAA,EAEAD,EAAAC,EAAA,EAEA,GAEAA,IAAA,IADAC,EAAAT,EAAAW,WAAAR,KAAA,MACAI,EACAA,GAAA,QACSE,GAAA,IAITL,GAAAF,EACAG,GAHA,EAAAG,OAAA,GAAAA,GAAA,EAKAF,EAAAV,MAAAQ,EAAAjB,EAAAkB,EAAAlB,IAGA,OAAAmB,GAUAtB,EAAAC,OAAA,SAAAqB,EAAAL,GACA,IAAAK,EAAAX,OAA8B,SAK9B,IAHA,IAAAR,EAAAC,KAAAsB,IAAA,GAAAT,GAAA,GACAX,EAAAL,EAAAqB,EAAA,MAAAnB,GAAAF,EAAAqB,EAAA,MAAAnB,GAEA9B,EAAA,EAAmBA,EAAAiD,EAAAX,OAAwBtC,IAAA,CAC3C,IAAAuD,EAAAN,EAAAjD,GAAAwD,EAAAP,EAAAjD,EAAA,GACAiC,GAAAL,EAAA2B,EAAA,GAAAC,EAAA,GAAA1B,GACAG,GAAAL,EAAA2B,EAAA,GAAAC,EAAA,GAAA1B,GAGA,OAAAG,GAkBAN,EAAA8B,YAAA,SAAAC,EAAAd,GAIA,GAHAc,GAAA,YAAAA,EAAAC,OACAD,IAAAE,WAEAF,GAAA,eAAAA,EAAAC,KACA,UAAAE,MAAA,sCAEA,OAAAlC,EAAAC,OAAAQ,EAAAsB,EAAAT,aAAAL,IAUAjB,EAAAF,UAAA,SAAAkB,EAAAC,GAEA,OACAe,KAAA,aACAV,YAAAb,EAHAT,EAAAe,OAAAC,EAAAC,MAOA,iBAAA7C,KAAAD,UACAC,EAAAD,QAAA6B,kBCtJA5B,EAAAD,QAAAgE,EACA/D,EAAAD,QAAAgE,QACA/D,EAAAD,QAAAiE,UAiOA,SAAAA,EAAAC,GACA,YAAAA,EAAAL,OACAK,IAAAJ,UAGA,SAAAK,EAAA5D,GACA,OAAAA,EAAA6D,KAAA,KAGA,SAAAC,EAAApD,GACA,OAAAA,EAAAqD,IAAAH,GAAAC,KAAA,MAGA,SAAAG,EAAAtD,GACA,OAAAA,EAAAqD,IAAAD,GAAAC,IAAAE,GAAAJ,KAAA,MAOA,SAAAI,EAAA9C,GAA2B,UAAAA,EAAA,IAE3B,OAAAwC,EAAAL,MACA,YACA,gBAAAM,EAAAD,EAAAf,aAAA,IACA,iBACA,qBAAAkB,EAAAH,EAAAf,aAAA,IACA,cACA,kBAAAoB,EAAAL,EAAAf,aAAA,IACA,iBACA,qBAAAkB,EAAAH,EAAAf,aAAA,IACA,mBACA,uBAAAe,EAAAf,YAfAmB,IAAAC,GAAAD,IAAAE,GAAAJ,KAAA,MAeA,IACA,sBACA,0BAAAG,EAAAL,EAAAf,aAAA,IACA,yBACA,6BAAAe,EAAAO,WAAAH,IAAAL,GAAAG,KAAA,UACA,QACA,UAAAL,MAAA,4EAtQA,IAAAW,EAAA,iDAEAC,EAAA,IAAAC,OAAA,IAAAF,EAAAG,OAAA,OAAAH,EAAAG,OAAA,SAQA,SAAAb,EAAAc,GACA,IAeAC,EAfAC,EAAAF,EAAAG,MAAA,KACAC,EAAAF,EAAAG,MACAC,GAAAJ,EAAA5B,SAAA,IAAA6B,MAAA,KAAAE,MAEAjF,EAAA,EAEA,SAAAmF,EAAAC,GACA,IAAAC,EAAAL,EAAAM,UAAAtF,GAAAqF,MAAAD,GACA,OAAAC,GAEArF,GAAAqF,EAAA,GAAA/C,OACA+C,EAAA,IAHA,KAoBA,SAAAE,IAAqBJ,EAAA,QAErB,SAAAK,IACAD,IAOA,IANA,IAIAE,EAJAC,EAAA,EACAC,KACAC,GAAAD,GACAE,EAAAF,EAGAF,EACAN,EAAA,UACAA,EAAA,UACAA,EAAA,UACAA,EAAAV,IAAA,CACA,SAAAgB,EACAG,EAAArD,KAAAsD,GACAA,KACAD,IAAAtD,OAAA,GAAAC,KAAAsD,GACAH,SACO,SAAAD,EAAA,CAEP,OAAAI,EAAAvD,OAAA,YAIA,KAFAuD,EAAAD,EAAAX,OAEA,YAEA,SADAS,EACA,WACO,SAAAD,EACPI,KACAD,IAAAtD,OAAA,GAAAC,KAAAsD,OACO,IAAAJ,EAAAV,MAAA,OAAAe,KAAAC,OAGP,YAFAC,MAAA3E,UAAAkB,KAAA0D,MAAAJ,EAAAJ,EAAAV,MAAA,OAAAX,IAAA8B,aAIAX,IAGA,WAAAG,EAAA,KAEAC,EAGA,SAAAtD,IAIA,IAHA,IACA8D,EACAC,EAFAC,KAGAD,EACAjB,EAAAV,IACAU,EAAA,UACA,MAAAiB,GACAC,EAAA9D,KAAA4D,GACAA,MACOC,EAAArB,MAAA,OAAAe,KAAAC,SACPI,UACAH,MAAA3E,UAAAkB,KAAA0D,MAAAE,EAAAC,EAAArB,MAAA,OAAAX,IAAA8B,cAEAX,IAGA,OAAAY,GAAAE,EAAA9D,KAAA4D,GAGAE,EAAA/D,OAAA+D,EAAA,MAFA,KAyGA,SAAAC,IACA,OArGA,WACA,IAAAnB,EAAA,yBAEA,GADAI,KACAJ,EAAA,qBACA,IAAA9E,EAAAgC,IACA,OAAAhC,GACAkF,IACAJ,EAAA,UAEAxB,KAAA,QACAV,YAAA5C,EAAA,IAHA,MAFA,KAgGAkG,IA1DA,WACA,IAAApB,EAAA,8BAEA,GADAI,KACAJ,EAAA,qBACA,IAAA9E,EAAAgC,IACA,OAAAhC,GACA8E,EAAA,UAEAxB,KAAA,aACAV,YAAA5C,GAJA,KAsDAmG,IA9CA,WACA,IAAArB,EAAA,2BACAI,IACA,IAAAlF,EAAAmF,IACA,OAAAnF,GAEAsD,KAAA,UACAV,YAAA5C,GAHA,KA2CAoG,IAzFA,WACA,IAAAtB,EAAA,8BACAI,IACA,IAAAmB,EAAA1B,EACAM,UAAAN,EAAA2B,QAAA,OAAA3B,EAAA1C,OAAA,GACAsE,QAAA,UACAA,QAAA,UACA5B,EAAA,eAAA0B,EAAA,IACA,IAAArG,EAAAmF,IACA,OAAAnF,GACAkF,KAEA5B,KAAA,aACAV,YAAA5C,IAJA,KAiFAwG,IAzEA,WACA,IAAA1B,EAAA,mCACAI,IACA,IAAAlF,EAAAmF,IACA,OAAAnF,GACAkF,KAEA5B,KAAA,kBACAV,YAAA5C,IAJA,KAsEAyG,IAtCA,WACA,IAAA3B,EAAA,gCACAI,IACA,IAAAlF,EAAAmF,IACA,OAAAnF,GAEAsD,KAAA,eACAV,YAAA5C,GAHA,KAmCA0G,IA5BA,WACA,IACAnD,EADAW,KAGA,IAAAY,EAAA,sCAGA,GAFAI,KAEAJ,EAAA,qBACA,KAAAvB,EAAA0C,KACA/B,EAAAhC,KAAAqB,GACA2B,IACAJ,EAAA,SACAI,IAEA,OAAAJ,EAAA,UAGAxB,KAAA,qBACAY,cAJA,KAeAyC,GAGA,OA/LAnC,EA+LAyB,MA9LApB,EAAAG,MAAA,SACAR,EAAAoC,KACAtD,KAAA,OACAuD,YACA3G,KAAA,yBAAA2E,KAKAL,kBCzCA9E,EAAAD,QAAAqH,6BC4FApH,EAAAD,QA5FA,SAAAsH,EAAAC,EAAAC,GACA,IAAAC,GAAA,EAEA,YAAAC,OAAAC,eACA,OAAAJ,EAAAxD,MAAA,0BAGA,YAAAyD,EAAA,CACA,IAAAlH,EAAAgH,EAAA/B,MAAA,yBACAiC,EAAAlH,KAAA,KAAAsH,SAAAC,SAAA,KAAAD,SAAAE,UACAF,SAAAG,KAAA,IAAAH,SAAAG,KAAA,IAGA,IAAAC,EAAA,IAAAN,OAAAC,eAMA,GAAAH,KAAA,oBAAAQ,GAAA,CAEAA,EAAA,IAAAN,OAAAO,eAKA,IAAAC,EAAAX,EACAA,EAAA,WACA,GAAAE,EACAS,EAAA/B,MAAAgC,KAAAC,eACa,CACb,IAAAC,EAAAF,KAAAG,EAAAF,UACAG,WAAA,WACAL,EAAA/B,MAAAkC,EAAAC,IACiB,KAKjB,SAAAE,IAxBA,IAAAC,OA2BAC,IAAAV,EAAAS,SA3BAA,EA6BAT,EAAAS,SA5BA,KAAAA,EAAA,WAAAA,EA4BAlB,EAAAlH,KAAA2H,EAAA,KAAAA,GACAT,EAAAlH,KAAA2H,IAAA,MA4CA,MAvCA,WAAAA,EACAA,EAAAW,OAAAH,EAEAR,EAAAY,mBAAA,WACA,IAAAZ,EAAAa,YACAL,KAOAR,EAAAc,QAAA,SAAAC,GAEAxB,EAAAlH,KAAA8H,KAAAY,IAAA,QACAxB,EAAA,cAIAS,EAAAgB,WAAA,aAEAhB,EAAAiB,UAAA,SAAAF,GACAxB,EAAAlH,KAAA8H,KAAAY,EAAA,MACAxB,EAAA,cAGAS,EAAAkB,QAAA,SAAAH,GACAxB,EAAAlH,KAAA8H,KAAAY,EAAA,MACAxB,EAAA,cAKAS,EAAAmB,KAAA,MAAA7B,GAAA,GAGAU,EAAAoB,KAAA,MACA3B,GAAA,EAEAO,oBCzFA,IAAAqB,EAAAvJ,EAAA,GACAuH,EAAAvH,EAAA,GACAwJ,EAAAxJ,EAAA,GACA+B,EAAA/B,EAAA,GACA8B,EAAA9B,EAAA,GACA6B,EAAA7B,EAAA,GAsBA,SAAAyJ,EAAApJ,EAAAK,GACA,eAAAL,EACAA,EAAAqJ,WAAAhJ,GACK,YAAAL,GACLA,EAAAoJ,QAAA/I,GA0JA,SAAAiJ,EAAAC,EAAAC,EAAAC,GACA,IAAAjJ,EAAA,iBAAA+I,EACAG,KAAA7F,MAAA0F,KAEA,QAAAxJ,KADA0J,KAAAE,EAAAC,UACApJ,EAAAqJ,QAAA,CACA,IAAAC,EAAArI,EAAAsI,QAAAvJ,IAAAqJ,QAAA9J,IACA+J,EAAAE,SAAAZ,EAAAK,EAAAK,EAAAE,UACAZ,EAAAK,EAAAK,GAEA,OAAAL,EAGA,SAAAQ,EAAAC,EAAAV,EAAAC,GAQA,OAPAA,KAAAE,EAAAC,UACAJ,QACAtC,cAAAgD,EAAAV,EACA,SAAAW,EAAA1G,GACA,GAAA0G,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7Cf,EAAAK,EAAAhG,KAEAgG,EAGA,SAAAa,EAAAC,EAAAf,EAAAC,GACA,IAAAe,EAAAC,EAAAF,GACA,OAAAC,GAKApB,EAFAK,KAAAE,EAAAC,UACApI,EAAA+I,IAAAC,IAEAf,GANAA,EAAAW,KAAA,SACAC,MAAA,wBASA,SAAAK,EAAAH,EAAAf,EAAAC,GACA,IAAAe,EAAAC,EAAAF,GACA,OAAAC,GAKApB,EAFAK,KAAAE,EAAAC,UACApI,EAAAmJ,IAAAH,IAEAf,GANAA,EAAAW,KAAA,SACAC,MAAA,wBAQA,SAAAO,EAAAC,EAAArB,EAAAC,GACAA,KAAAE,EAAAC,UACAJ,QAGA,IAFA,IAAApH,EAAAV,EAAAe,OAAAoI,EAAArB,EAAA7G,WACAc,GAAmBC,KAAA,aAAAV,gBACnBjD,EAAA,EAAmBA,EAAAqC,EAAAC,OAAmBtC,IAEtC0D,EAAAT,YAAAjD,IAAAqC,EAAArC,GAAA,GAAAqC,EAAArC,GAAA,IAGA,OADAqJ,EAAAK,EAAAhG,GACAgG,EAGA,SAAAqB,EAAAC,EAAAvB,EAAAC,GAIA,OADAL,EAFAK,KAAAE,EAAAC,UACAT,EAAA4B,IAEAtB,EAGA,SAAAgB,EAAA/H,GACA,uBAAAA,GACA,IAAAsI,WAAAC,gBAAAvI,EAAA,YAEAA,EAxPA5C,EAAAD,QAAA6B,SAuKA,SAAAyF,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAOA,OANAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,GAAAhB,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7CS,EAAAO,EAAAC,aAAA5B,EAAAC,GACAA,EAAAW,KAAA,WAEAX,GA9KA3J,EAAAD,QAAA6B,SAAAmC,MAAA+G,EAEA9K,EAAAD,QAAA4D,QAiCA,SAAA0D,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAMA,OALAV,EAAA/B,EAAA,SAAAgD,EAAAgB,GACA,GAAAhB,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7Cf,EAAAK,EAAAC,KAAA7F,MAAAsH,EAAAC,eACA3B,EAAAW,KAAA,WAEAX,GAtCA3J,EAAAD,QAAA4B,SAiDA,SAAA0F,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAOA,OANAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,GAAAhB,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7Cb,EAAA6B,EAAAC,aAAA5B,EAAAC,GACAA,EAAAW,KAAA,WAEAX,GAxDA3J,EAAAD,QAAA4B,SAAAoC,MAAAyF,EAEAxJ,EAAAD,QAAAqK,IAiEA,SAAA/C,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAaA,OAZAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,IAAAd,EACA,GAAAF,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7C,SAAAkB,IACAhB,GAAA,EAEAZ,EAAA6B,GAAA,QAAAD,GACApB,EAAAkB,EAAAC,aAAA5B,EAAAC,GACAA,EAAA8B,IAAA,QAAAF,GACAhB,GAAAZ,EAAAW,KAAA,WAEAX,GA9EA3J,EAAAD,QAAAqK,IAAArG,MAAAoG,EAEAnK,EAAAD,QAAA0K,IAuFA,SAAApD,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAaA,OAZAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,IAAAd,EACA,GAAAF,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7C,SAAAkB,IACAhB,GAAA,EAEAZ,EAAA6B,GAAA,QAAAD,GACAf,EAAAa,EAAAK,aAAAL,EAAAC,aAAA5B,EAAAC,GACAA,EAAA8B,IAAA,QAAAF,GACAhB,GAAAZ,EAAAW,KAAA,WAEAX,GApGA3J,EAAAD,QAAA0K,IAAA1G,MAAAyG,EAEAxK,EAAAD,QAAA8K,IA6GA,SAAAxD,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAaA,OAZAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,IAAAd,EACA,GAAAF,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7C,SAAAkB,IACAhB,GAAA,EAEAZ,EAAA6B,GAAA,QAAAD,GACAX,EAAAS,EAAAK,aAAAL,EAAAC,aAAA5B,EAAAC,GACAA,EAAA8B,IAAA,QAAAF,GACAhB,GAAAZ,EAAAW,KAAA,WAEAX,GA1HA3J,EAAAD,QAAA8K,IAAA9G,MAAA6G,EAEA5K,EAAAD,QAAAkL,IAmIA,SAAA5D,EAAAqC,EAAA0B,GACA,IAAAzB,EAAAyB,GAAAvB,EAAAC,UAOA,OANAV,EAAA/B,EACA,SAAAgD,EAAAgB,GACA,GAAAhB,EAAA,OAAAV,EAAAW,KAAA,SAA6CC,MAAAF,IAC7CW,EAAAK,EAAAC,aAAA5B,EAAAC,GACAA,EAAAW,KAAA,WAEAX,GA1IA3J,EAAAD,QAAAkL,IAAAlH,MAAAiH","file":"lfx-omnivore-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = toGeoJSON;","module.exports = topojson;","'use strict';\n\n/**\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction encode(coordinate, factor) {\n    coordinate = Math.round(coordinate * factor);\n    coordinate <<= 1;\n    if (coordinate < 0) {\n        coordinate = ~coordinate;\n    }\n    var output = '';\n    while (coordinate >= 0x20) {\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\n        coordinate >>= 5;\n    }\n    output += String.fromCharCode(coordinate + 63);\n    return output;\n}\n\n/**\n * Decodes to a [latitude, longitude] coordinates array.\n *\n * This is adapted from the implementation in Project-OSRM.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Array}\n *\n * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n */\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, precision || 5);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\npolyline.encode = function(coordinates, precision) {\n    if (!coordinates.length) { return ''; }\n\n    var factor = Math.pow(10, precision || 5),\n        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n    for (var i = 1; i < coordinates.length; i++) {\n        var a = coordinates[i], b = coordinates[i - 1];\n        output += encode(a[0] - b[0], factor);\n        output += encode(a[1] - b[1], factor);\n    }\n\n    return output;\n};\n\nfunction flipped(coords) {\n    var flipped = [];\n    for (var i = 0; i < coords.length; i++) {\n        flipped.push(coords[i].slice().reverse());\n    }\n    return flipped;\n}\n\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\npolyline.fromGeoJSON = function(geojson, precision) {\n    if (geojson && geojson.type === 'Feature') {\n        geojson = geojson.geometry;\n    }\n    if (!geojson || geojson.type !== 'LineString') {\n        throw new Error('Input must be a GeoJSON LineString');\n    }\n    return polyline.encode(flipped(geojson.coordinates), precision);\n};\n\n/**\n * Decodes to a GeoJSON LineString geometry.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Object}\n */\npolyline.toGeoJSON = function(str, precision) {\n    var coords = polyline.decode(str, precision);\n    return {\n        type: 'LineString',\n        coordinates: flipped(coords)\n    };\n};\n\nif (typeof module === 'object' && module.exports) {\n    module.exports = polyline;\n}\n","/*eslint-disable no-cond-assign */\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\nvar numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n\n/*\n * Parse WKT and return GeoJSON.\n *\n * @param {string} _ A WKT geometry\n * @return {?Object} A GeoJSON geometry object\n */\nfunction parse (input) {\n  var parts = input.split(';');\n  var _ = parts.pop();\n  var srid = (parts.shift() || '').split('=').pop();\n\n  var i = 0;\n\n  function $ (re) {\n    var match = _.substring(i).match(re);\n    if (!match) return null;\n    else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs (obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white () { $(/^\\s*/); }\n\n  function multicoords () {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem =\n           $(/^(\\()/) ||\n             $(/^(\\))/) ||\n               $(/^(\\,)/) ||\n                 $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n\n        pointer = stack.pop();\n        // the stack was empty, input was malformed\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n      white();\n    }\n\n    if (depth !== 0) return null;\n\n    return rings;\n  }\n\n  function coords () {\n    var list = [];\n    var item;\n    var pt;\n    while (pt =\n           $(tuples) ||\n             $(/^(\\,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n      white();\n    }\n\n    if (item) list.push(item);\n    else return null;\n\n    return list.length ? list : null;\n  }\n\n  function point () {\n    if (!$(/^(point)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint () {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n    var newCoordsFormat = _\n      .substring(_.indexOf('(') + 1, _.length - 1)\n      .replace(/\\(/g, '')\n      .replace(/\\)/g, '');\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring () {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring () {\n    if (!$(/^(linestring)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon () {\n    if (!$(/^(polygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon () {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection () {\n    var geometries = [];\n    var geometry;\n\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n\n    if (!$(/^(\\()/)) return null;\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(\\,)/);\n      white();\n    }\n    if (!$(/^(\\))/)) return null;\n\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root () {\n    return point() ||\n      linestring() ||\n      polygon() ||\n      multipoint() ||\n      multilinestring() ||\n      multipolygon() ||\n      geometrycollection();\n  }\n\n  return crs(root());\n}\n\n/**\n * Stringifies a GeoJSON object into WKT\n */\nfunction stringify (gj) {\n  if (gj.type === 'Feature') {\n    gj = gj.geometry;\n  }\n\n  function pairWKT (c) {\n    return c.join(' ');\n  }\n\n  function ringWKT (r) {\n    return r.map(pairWKT).join(', ');\n  }\n\n  function ringsWKT (r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n  }\n\n  function multiRingsWKT (r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n  }\n\n  function wrapParens (s) { return '(' + s + ')'; }\n\n  switch (gj.type) {\n    case 'Point':\n      return 'POINT (' + pairWKT(gj.coordinates) + ')';\n    case 'LineString':\n      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';\n    case 'Polygon':\n      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';\n    case 'MultiPoint':\n      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';\n    case 'MultiPolygon':\n      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';\n    case 'MultiLineString':\n      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';\n    case 'GeometryCollection':\n      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';\n    default:\n      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n  }\n}\n","module.exports = csv2geojson;","function corslite(url, callback, cors) {\n    var sent = false;\n\n    if (typeof window.XMLHttpRequest === 'undefined') {\n        return callback(Error('Browser not supported'));\n    }\n\n    if (typeof cors === 'undefined') {\n        var m = url.match(/^\\s*https?:\\/\\/[^\\/]*/);\n        cors = m && (m[0] !== location.protocol + '//' + location.hostname +\n                (location.port ? ':' + location.port : ''));\n    }\n\n    var x = new window.XMLHttpRequest();\n\n    function isSuccessful(status) {\n        return status >= 200 && status < 300 || status === 304;\n    }\n\n    if (cors && !('withCredentials' in x)) {\n        // IE8-9\n        x = new window.XDomainRequest();\n\n        // Ensure callback is never called synchronously, i.e., before\n        // x.send() returns (this has been observed in the wild).\n        // See https://github.com/mapbox/mapbox.js/issues/472\n        var original = callback;\n        callback = function() {\n            if (sent) {\n                original.apply(this, arguments);\n            } else {\n                var that = this, args = arguments;\n                setTimeout(function() {\n                    original.apply(that, args);\n                }, 0);\n            }\n        }\n    }\n\n    function loaded() {\n        if (\n            // XDomainRequest\n            x.status === undefined ||\n            // modern browsers\n            isSuccessful(x.status)) callback.call(x, null, x);\n        else callback.call(x, x, null);\n    }\n\n    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`\n    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).\n    if ('onload' in x) {\n        x.onload = loaded;\n    } else {\n        x.onreadystatechange = function readystate() {\n            if (x.readyState === 4) {\n                loaded();\n            }\n        };\n    }\n\n    // Call the callback with the XMLHttpRequest object as an error and prevent\n    // it from ever being called again by reassigning it to `noop`\n    x.onerror = function error(evt) {\n        // XDomainRequest provides no evt parameter\n        callback.call(this, evt || true, null);\n        callback = function() { };\n    };\n\n    // IE9 must have onprogress be set to a unique function.\n    x.onprogress = function() { };\n\n    x.ontimeout = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    x.onabort = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    // GET is the only supported HTTP Verb by XDomainRequest and is the\n    // only one supported here.\n    x.open('GET', url, true);\n\n    // Send the request. Sending data is not supported.\n    x.send(null);\n    sent = true;\n\n    return x;\n}\n\nif (typeof module !== 'undefined') module.exports = corslite;\n","var xhr = require('corslite'),\n    csv2geojson = require('csv2geojson'),\n    wellknown = require('wellknown'),\n    polyline = require('polyline'),\n    topojson = require('topojson'),\n    toGeoJSON = require('togeojson');\n\nmodule.exports.polyline = polylineLoad;\nmodule.exports.polyline.parse = polylineParse;\n\nmodule.exports.geojson = geojsonLoad;\n\nmodule.exports.topojson = topojsonLoad;\nmodule.exports.topojson.parse = topojsonParse;\n\nmodule.exports.csv = csvLoad;\nmodule.exports.csv.parse = csvParse;\n\nmodule.exports.gpx = gpxLoad;\nmodule.exports.gpx.parse = gpxParse;\n\nmodule.exports.kml = kmlLoad;\nmodule.exports.kml.parse = kmlParse;\n\nmodule.exports.wkt = wktLoad;\nmodule.exports.wkt.parse = wktParse;\n\nfunction addData(l, d) {\n    if ('setGeoJSON' in l) {\n        l.setGeoJSON(d);\n    } else if ('addData' in l) {\n        l.addData(d);\n    }\n}\n\n/**\n * Load a [GeoJSON](http://geojson.org/) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction geojsonLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, function(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        addData(layer, JSON.parse(response.responseText));\n        layer.fire('ready');\n    });\n    return layer;\n}\n\n/**\n * Load a [TopoJSON](https://github.com/mbostock/topojson) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction topojsonLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        topojsonParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a CSV document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction csvLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        csvParse(response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a GPX document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction gpxLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        gpxParse(response.responseXML || response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a [KML](https://developers.google.com/kml/documentation/) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction kmlLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        kmlParse(response.responseXML || response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a WKT (Well Known Text) string into a layer and return the layer\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction wktLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        wktParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a polyline string into a layer and return the layer\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction polylineLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        polylineParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\nfunction topojsonParse(data, options, layer) {\n    var o = typeof data === 'string' ?\n        JSON.parse(data) : data;\n    layer = layer || L.geoJson();\n    for (var i in o.objects) {\n        var ft = topojson.feature(o, o.objects[i]);\n        if (ft.features) addData(layer, ft.features);\n        else addData(layer, ft);\n    }\n    return layer;\n}\n\nfunction csvParse(csv, options, layer) {\n    layer = layer || L.geoJson();\n    options = options || {};\n    csv2geojson.csv2geojson(csv, options, onparse);\n    function onparse(err, geojson) {\n        if (err) return layer.fire('error', { error: err });\n        addData(layer, geojson);\n    }\n    return layer;\n}\n\nfunction gpxParse(gpx, options, layer) {\n    var xml = parseXML(gpx);\n    if (!xml) return layer.fire('error', {\n        error: 'Could not parse GPX'\n    });\n    layer = layer || L.geoJson();\n    var geojson = toGeoJSON.gpx(xml);\n    addData(layer, geojson);\n    return layer;\n}\n\n\nfunction kmlParse(gpx, options, layer) {\n    var xml = parseXML(gpx);\n    if (!xml) return layer.fire('error', {\n        error: 'Could not parse KML'\n    });\n    layer = layer || L.geoJson();\n    var geojson = toGeoJSON.kml(xml);\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction polylineParse(txt, options, layer) {\n    layer = layer || L.geoJson();\n    options = options || {};\n    var coords = polyline.decode(txt, options.precision);\n    var geojson = { type: 'LineString', coordinates: [] };\n    for (var i = 0; i < coords.length; i++) {\n        // polyline returns coords in lat, lng order, so flip for geojson\n        geojson.coordinates[i] = [coords[i][1], coords[i][0]];\n    }\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction wktParse(wkt, options, layer) {\n    layer = layer || L.geoJson();\n    var geojson = wellknown(wkt);\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction parseXML(str) {\n    if (typeof str === 'string') {\n        return (new DOMParser()).parseFromString(str, 'text/xml');\n    } else {\n        return str;\n    }\n}\n"],"sourceRoot":""}